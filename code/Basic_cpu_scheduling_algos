

#include <bits/stdc++.h>
using namespace std;

/*
Energy-efficient CPU Scheduling Simulator
Supports: FCFS, SJF (non-preemptive), Round Robin (preemptive), Priority (non-preemptive)
Metrics per process: Waiting Time, Turnaround Time, Energy used
Energy model:
  energy_process = ACTIVE_POWER * burst_time + SWITCH_ENERGY * times_scheduled
  ACTIVE_POWER in Joules per time unit (assume 1 time unit = 1 second, adjust in report)
  SWITCH_ENERGY in Joules per context switch (fixed overhead per scheduling event)
*/

struct Process {
    int pid;
    int arrival;
    int burst;
    int priority;
};

struct Result {
    vector<int> completion_time;
    vector<int> waiting_time;
    vector<int> turnaround_time;
    vector<int> times_scheduled; // how many times process was given CPU
    vector<double> energy; // energy per process
    vector<pair<int,int>> gantt; // pairs <time, pid> representing start time and pid (pid=-1 for idle)
};

// Energy model constants (tweak in report)
const double ACTIVE_POWER = 1.0;    // joules per time unit (per unit of burst)
const double SWITCH_ENERGY = 0.5;   // joules per scheduling event (context switch)

void print_process_table(const vector<Process>& procs) {
    cout << "PID\tArrival\tBurst\tPriority\n";
    for (auto &p: procs)
        cout << p.pid << "\t" << p.arrival << "\t" << p.burst << "\t" << p.priority << "\n";
    cout << "\n";
}

void print_results(const string& name, const vector<Process>& procs, const Result& r) {
    int n = procs.size();
    cout << "----- " << name << " -----\n";
    cout << "Gantt Chart (start_time:PID):\n";
    for (auto &e: r.gantt) {
        if (e.second == -1) cout << e.first << ":idle ";
        else cout << e.first << ":P" << e.second << " ";
    }
    cout << "\n\nPID\tArrival\tBurst\tWT\tTAT\tTimesScheduled\tEnergy(J)\n";
    double totalEnergy = 0;
    double totalWT = 0, totalTAT = 0;
    for (int i=0;i<n;i++) {
        cout << procs[i].pid << "\t" << procs[i].arrival << "\t" << procs[i].burst << "\t"
             << r.waiting_time[i] << "\t" << r.turnaround_time[i] << "\t"
             << r.times_scheduled[i] << "\t\t" << fixed << setprecision(3) << r.energy[i] << "\n";
        totalEnergy += r.energy[i];
        totalWT += r.waiting_time[i];
        totalTAT += r.turnaround_time[i];
    }
    cout << "\nAvg Waiting Time: " << (totalWT/n) << "\n";
    cout << "Avg Turnaround Time: " << (totalTAT/n) << "\n";
    cout << "Total Energy (J): " << totalEnergy << "\n\n";
}

Result compute_energy_and_finalize(const vector<Process>& procs,
                                   vector<int>& completion,
                                   vector<int>& times_scheduled,
                                   const vector<pair<int,int>>& ganttSegments)
{
    int n = procs.size();
    Result res;
    res.completion_time = completion;
    res.times_scheduled = times_scheduled;
    res.gantt = ganttSegments;

    res.waiting_time.assign(n,0);
    res.turnaround_time.assign(n,0);
    res.energy.assign(n,0.0);

    for (int i=0;i<n;i++) {
        res.turnaround_time[i] = res.completion_time[i] - procs[i].arrival;
        res.waiting_time[i] = res.turnaround_time[i] - procs[i].burst;
        if (res.waiting_time[i] < 0) res.waiting_time[i] = 0; // safety
        // Energy model:
        res.energy[i] = ACTIVE_POWER * procs[i].burst + SWITCH_ENERGY * res.times_scheduled[i];
    }
    return res;
}

/* FCFS - non-preemptive */
Result simulate_FCFS(vector<Process> procs) {
    int n = procs.size();
    // sort by arrival then pid
    vector<Process> order = procs;
    sort(order.begin(), order.end(), [](const Process&a, const Process&b){
        if (a.arrival != b.arrival) return a.arrival < b.arrival;
        return a.pid < b.pid;
    });

    vector<int> completion(n,0), times_scheduled(n,0);
    vector<pair<int,int>> gantt; // start_time,pid
    int currentTime = 0;
    for (auto &p : order) {
        int idx = p.pid - 1;
        if (currentTime < p.arrival) {
            // idle
            gantt.push_back({currentTime, -1});
            currentTime = p.arrival;
        }
        // process starts now
        gantt.push_back({currentTime, p.pid});
        times_scheduled[idx] += 1;
        currentTime += p.burst;
        completion[idx] = currentTime;
    }

    // If some processes had same pid ordering different? We filled completion for each pid above.
    return compute_energy_and_finalize(procs, completion, times_scheduled, gantt);
}

/* SJF Non-preemptive */
Result simulate_SJF_nonpreemptive(vector<Process> procs) {
    int n = procs.size();
    vector<int> completion(n,0), times_scheduled(n,0);
    vector<pair<int,int>> gantt;
    int completed = 0;
    int currentTime = 0;
    vector<bool> done(n,false);

    while (completed < n) {
        // find available with smallest burst among arrived and not done
        int idx = -1;
        int bestBurst = INT_MAX;
        for (int i=0;i<n;i++) {
            if (!done[i] && procs[i].arrival <= currentTime) {
                if (procs[i].burst < bestBurst || (procs[i].burst==bestBurst && procs[i].arrival < procs[idx].arrival)) {
                    bestBurst = procs[i].burst;
                    idx = i;
                }
            }
        }
        if (idx == -1) {
            // idle until next arrival
            int nextArrival = INT_MAX;
            for (int i=0;i<n;i++) if (!done[i]) nextArrival = min(nextArrival, procs[i].arrival);
            gantt.push_back({currentTime, -1});
            currentTime = nextArrival;
            continue;
        }
        // schedule idx
        gantt.push_back({currentTime, procs[idx].pid});
        times_scheduled[idx] += 1;
        currentTime += procs[idx].burst;
        completion[idx] = currentTime;
        done[idx] = true;
        completed++;
    }

    return compute_energy_and_finalize(procs, completion, times_scheduled, gantt);
}

/* Priority Scheduling - non-preemptive (lower number = higher priority)
   tie-breaker: arrival time then PID */
Result simulate_Priority_nonpreemptive(vector<Process> procs) {
    int n = procs.size();
    vector<int> completion(n,0), times_scheduled(n,0);
    vector<pair<int,int>> gantt;
    int completed = 0;
    int currentTime = 0;
    vector<bool> done(n,false);

    while (completed < n) {
        int idx = -1;
        int bestPriority = INT_MAX;
        for (int i=0;i<n;i++) {
            if (!done[i] && procs[i].arrival <= currentTime) {
                if (procs[i].priority < bestPriority ||
                   (procs[i].priority==bestPriority && procs[i].arrival < procs[idx].arrival)) {
                    bestPriority = procs[i].priority;
                    idx = i;
                }
            }
        }
        if (idx == -1) {
            int nextArrival = INT_MAX;
            for (int i=0;i<n;i++) if (!done[i]) nextArrival = min(nextArrival, procs[i].arrival);
            gantt.push_back({currentTime, -1});
            currentTime = nextArrival;
            continue;
        }
        gantt.push_back({currentTime, procs[idx].pid});
        times_scheduled[idx] += 1;
        currentTime += procs[idx].burst;
        completion[idx] = currentTime;
        done[idx] = true;
        completed++;
    }
    return compute_energy_and_finalize(procs, completion, times_scheduled, gantt);
}

/* Round Robin preemptive */
Result simulate_RR(vector<Process> procs, int quantum) {
    int n = procs.size();
    vector<int> remaining(n), completion(n,0), times_scheduled(n,0);
    for (int i=0;i<n;i++) remaining[i]=procs[i].burst;

    // Event-driven: maintain ready queue by arrival times
    int currentTime = 0;
    queue<int> ready; // store indexes
    vector<bool> inQueue(n,false);
    vector<pair<int,int>> gantt;

    // push processes arriving at time 0
    for (int i=0;i<n;i++) {
        if (procs[i].arrival <= currentTime && !inQueue[i]) {
            ready.push(i);
            inQueue[i]=true;
        }
    }

    // if no one at time 0, advance to earliest arrival
    if (ready.empty()) {
        int mn = INT_MAX;
        for (int i=0;i<n;i++) mn = min(mn, procs[i].arrival);
        gantt.push_back({currentTime, -1});
        currentTime = mn;
        for (int i=0;i<n;i++) if (procs[i].arrival <= currentTime && !inQueue[i]) {
            ready.push(i); inQueue[i]=true;
        }
    }

    while (!ready.empty()) {
        int idx = ready.front(); ready.pop();
        // if process hasn't arrived (shouldn't happen) skip
        if (procs[idx].arrival > currentTime) {
            // idle until it arrives
            gantt.push_back({currentTime, -1});
            currentTime = procs[idx].arrival;
        }
        // schedule it for min(quantum, remaining)
        gantt.push_back({currentTime, procs[idx].pid});
        times_scheduled[idx] += 1;
        int exec = min(quantum, remaining[idx]);
        currentTime += exec;
        remaining[idx] -= exec;

        // add newly arrived processes to ready queue
        for (int i=0;i<n;i++) {
            if (!inQueue[i] && remaining[i]>0 && procs[i].arrival <= currentTime) {
                ready.push(i);
                inQueue[i] = true;
            }
        }
        // if process still has remaining time, push it back
        if (remaining[idx] > 0) {
            ready.push(idx);
        } else {
            completion[idx] = currentTime;
        }
        // if queue empty but some remaining tasks haven't arrived yet -> advance time and enqueue arrived ones
        if (ready.empty()) {
            int nextArr = INT_MAX;
            for (int i=0;i<n;i++) if (remaining[i] > 0) nextArr = min(nextArr, procs[i].arrival);
            if (nextArr != INT_MAX && currentTime < nextArr) {
                gantt.push_back({currentTime, -1});
                currentTime = nextArr;
                for (int i=0;i<n;i++) if (!inQueue[i] && remaining[i]>0 && procs[i].arrival <= currentTime) {
                    ready.push(i); inQueue[i] = true;
                }
            }
        }
    }

    // completion times for processes that finished earlier are set; ensure completions are set
    for (int i=0;i<n;i++) if (completion[i]==0) completion[i] = procs[i].arrival + procs[i].burst; // fallback

    return compute_energy_and_finalize(procs, completion, times_scheduled, gantt);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cout << "Energy-Efficient CPU Scheduling Simulator\n";
    cout << "Enter number of processes: ";
    int n;
    if (!(cin >> n) || n <= 0) {
        cout << "Invalid number of processes. Exiting.\n";
        return 0;
    }
    vector<Process> procs(n);
    cout << "Provide process details. PID will be assigned 1..n automatically.\n";
    for (int i=0;i<n;i++) {
        procs[i].pid = i+1;
    }
    cout << "Enter arrival times (space separated) for " << n << " processes:\n";
    for (int i=0;i<n;i++) {
        int a; cin >> a; procs[i].arrival = a;
    }
    cout << "Enter burst times (space separated) for " << n << " processes:\n";
    for (int i=0;i<n;i++) {
        int b; cin >> b; procs[i].burst = b;
    }
    cout << "Enter priorities (integer) for " << n << " processes (lower= higher priority):\n";
    for (int i=0;i<n;i++) {
        int pr; cin >> pr; procs[i].priority = pr;
    }

    cout << "\nYou entered:\n";
    print_process_table(procs);

    cout << "Enter quantum for Round Robin (positive integer): ";
    int quantum; cin >> quantum;
    if (quantum <= 0) quantum = 1;

    // Run simulations
    Result res_fcfs = simulate_FCFS(procs);
    Result res_sjf = simulate_SJF_nonpreemptive(procs);
    Result res_prio = simulate_Priority_nonpreemptive(procs);
    Result res_rr = simulate_RR(procs, quantum);

    // Print detailed results
    print_results("FCFS", procs, res_fcfs);
    print_results("SJF (Non-preemptive)", procs, res_sjf);
    print_results("Priority (Non-preemptive)", procs, res_prio);
    print_results("Round Robin (quantum=" + to_string(quantum) + ")", procs, res_rr);

    // Comparison table: avg WT, avg TAT, total energy
    auto compute_stats = [&](const Result &r) {
        int N = procs.size();
        double totalWT=0, totalTAT=0, totalEnergy=0;
        for (int i=0;i<N;i++) { totalWT += r.waiting_time[i]; totalTAT += r.turnaround_time[i]; totalEnergy += r.energy[i]; }
        return tuple<double,double,double>(totalWT/N, totalTAT/N, totalEnergy);
    };

    double fcfs_wt, fcfs_tat, fcfs_energy;
    tie(fcfs_wt, fcfs_tat, fcfs_energy) = compute_stats(res_fcfs);
    double sjf_wt, sjf_tat, sjf_energy;
    tie(sjf_wt, sjf_tat, sjf_energy) = compute_stats(res_sjf);
    double prio_wt, prio_tat, prio_energy;
    tie(prio_wt, prio_tat, prio_energy) = compute_stats(res_prio);
    double rr_wt, rr_tat, rr_energy;
    tie(rr_wt, rr_tat, rr_energy) = compute_stats(res_rr);

    cout << "===== Comparison Table =====\n";
    cout << "Algo\t\tAvgWT\t\tAvgTAT\t\tTotalEnergy(J)\n";
    cout << "FCFS\t\t" << fcfs_wt << "\t\t" << fcfs_tat << "\t\t" << fcfs_energy << "\n";
    cout << "SJF\t\t" << sjf_wt << "\t\t" << sjf_tat << "\t\t" << sjf_energy << "\n";
    cout << "Priority\t" << prio_wt << "\t\t" << prio_tat << "\t\t" << prio_energy << "\n";
    cout << "RR(q=" << quantum << ")\t\t" << rr_wt << "\t\t" << rr_tat << "\t\t" << rr_energy << "\n";

    cout << "\nConclusion hint:\n";
    cout << "- Compare Avg Waiting Time and Avg Turnaround Time: SJF often minimizes average turnaround and waiting times for non-preemptive workloads.\n";
    cout << "- Energy wise (with our model) algorithms that reduce total CPU active time and reduce number of scheduling events (times_scheduled) will save energy.\n";
    cout << "- Round Robin may increase context switches -> higher SWITCH_ENERGY contribution; tune quantum to trade latency vs energy.\n";

    cout << "\n(You can paste this output into your report's results section and include the energy model description.)\n";
    return 0;
}
