#include <bits/stdc++.h>
using namespace std;

/*
ENERGY-EFFICIENT CPU SCHEDULING SIMULATOR
----------------------------------------
Algorithms:
- FCFS
- SJF (Non-preemptive)
- Priority (Non-preemptive)
- Round Robin (Preemptive)

Metrics per process:
- Waiting Time (WT)
- Turnaround Time (TAT)
- Times CPU was scheduled
- Energy consumed

Energy Model:
    ENERGY = (ACTIVE_POWER × burst_time) + (SWITCH_ENERGY × times_scheduled)
*/

struct Process {
    int pid;
    int arrival;
    int burst;
    int priority;
};

struct Result {
    vector<int> completion;
    vector<int> waiting;
    vector<int> tat;
    vector<int> times_scheduled;
    vector<double> energy;
    vector<pair<int,int>> gantt; // <start_time, pid>, pid = -1 → idle
};

// Energy constants
const double ACTIVE_POWER = 1.0;     // Joules per CPU active time
const double SWITCH_ENERGY = 0.5;    // Joules per context switch

// --------------------- Utility Printers -----------------------

void show_processes(const vector<Process>& p){
    cout << "\nPID\tArrival\tBurst\tPriority\n";
    for (auto &x : p)
        cout << x.pid << "\t" << x.arrival << "\t" << x.burst << "\t" << x.priority << "\n";
    cout << "\n";
}

void show_results(string name, const vector<Process> &p, const Result &r){
    cout << "\n========== " << name << " ==========\n";

    cout << "Gantt Chart:\n";
    for (auto &g : r.gantt) {
        if (g.second == -1) cout << g.first << ":IDLE  ";
        else cout << g.first << ":P" << g.second << "  ";
    }
    cout << "\n\n";

    cout << "PID\tWT\tTAT\tTimes\tEnergy(J)\n";
    double totalE=0, totalWT=0, totalTAT=0;
    int n = p.size();

    for (int i=0;i<n;i++){
        cout << p[i].pid << "\t"
             << r.waiting[i] << "\t"
             << r.tat[i] << "\t"
             << r.times_scheduled[i] << "\t"
             << fixed << setprecision(2) << r.energy[i] << "\n";

        totalE += r.energy[i];
        totalWT += r.waiting[i];
        totalTAT += r.tat[i];
    }

    cout << "\nAvg WT = " << totalWT/n;
    cout << "\nAvg TAT = " << totalTAT/n;
    cout << "\nTotal Energy = " << totalE << " J\n\n";
}

// -------------------- Common Finalization -----------------------

Result finalize_result(const vector<Process>& p,
                       vector<int>& completion,
                       vector<int>& times,
                       vector<pair<int,int>> gantt)
{
    int n = p.size();
    Result r;
    r.completion = completion;
    r.times_scheduled = times;
    r.gantt = gantt;

    r.waiting.assign(n,0);
    r.tat.assign(n,0);
    r.energy.assign(n,0);

    for(int i=0;i<n;i++){
        r.tat[i] = r.completion[i] - p[i].arrival;
        r.waiting[i] = r.tat[i] - p[i].burst;
        if (r.waiting[i] < 0) r.waiting[i] = 0;

        r.energy[i] = ACTIVE_POWER * p[i].burst + SWITCH_ENERGY * r.times_scheduled[i];
    }

    return r;
}

// --------------------------- FCFS ------------------------------

Result FCFS(vector<Process> p){
    int n = p.size();
    sort(p.begin(), p.end(), [](auto &a, auto &b){
        return a.arrival < b.arrival;
    });

    vector<int> completion(n,0), times(n,0);
    vector<pair<int,int>> gantt;

    int time = 0;

    for (auto &pr : p){
        if (time < pr.arrival){
            gantt.push_back({time, -1});
            time = pr.arrival;
        }
        gantt.push_back({time, pr.pid});
        times[pr.pid-1]++;

        time += pr.burst;
        completion[pr.pid-1] = time;
    }

    return finalize_result(p, completion, times, gantt);
}

// --------------------------- SJF ------------------------------

Result SJF(vector<Process> p){
    int n = p.size();
    vector<bool> done(n,false);
    vector<int> completion(n,0), times(n,0);
    vector<pair<int,int>> gantt;

    int finished = 0, time = 0;

    while (finished < n){
        int idx = -1, best = 999999;

        for (int i=0;i<n;i++){
            if (!done[i] && p[i].arrival <= time && p[i].burst < best){
                best = p[i].burst;
                idx = i;
            }
        }

        if (idx == -1){
            gantt.push_back({time, -1});
            time++;
            continue;
        }

        gantt.push_back({time, p[idx].pid});
        times[p[idx].pid-1]++;

        time += p[idx].burst;
        completion[p[idx].pid-1] = time;
        done[idx] = true;
        finished++;
    }

    return finalize_result(p, completion, times, gantt);
}

// ------------------------ Priority -----------------------------

Result PriorityAlgo(vector<Process> p){
    int n = p.size();
    vector<bool> done(n,false);
    vector<int> completion(n,0), times(n,0);
    vector<pair<int,int>> gantt;

    int finished = 0, time = 0;

    while (finished < n){
        int idx = -1, best = 999999;

        for (int i=0;i<n;i++){
            if (!done[i] && p[i].arrival <= time && p[i].priority < best){
                best = p[i].priority;
                idx = i;
            }
        }

        if (idx == -1){
            gantt.push_back({time, -1});
            time++;
            continue;
        }

        gantt.push_back({time, p[idx].pid});
        times[p[idx].pid-1]++;

        time += p[idx].burst;
        completion[p[idx].pid-1] = time;
        done[idx] = true;
        finished++;
    }

    return finalize_result(p, completion, times, gantt);
}

// ------------------------ Round Robin -----------------------------

Result RoundRobin(vector<Process> p, int q){
    int n = p.size();
    vector<int> rem(n), completion(n,0), times(n,0);
    vector<pair<int,int>> gantt;

    for (int i=0;i<n;i++) rem[i] = p[i].burst;

    queue<int> rq;
    int time = 0;

    while (true){
        bool allDone = true;

        for (int i=0;i<n;i++){
            if (p[i].arrival <= time && rem[i] > 0) rq.push(i);
            if (rem[i] > 0) allDone = false;
        }

        if (allDone) break;

        if (rq.empty()){
            gantt.push_back({time, -1});
            time++;
            continue;
        }

        int idx = rq.front(); rq.pop();

        if (rem[idx] > 0){
            gantt.push_back({time, p[idx].pid});
            times[p[idx].pid-1]++;

            int run = min(q, rem[idx]);
            rem[idx] -= run;
            time += run;

            if (rem[idx] == 0) completion[p[idx].pid-1] = time;
        }
    }

    return finalize_result(p, completion, times, gantt);
}

// ============================ MAIN ===============================

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    vector<Process> P(n);

    for (int i=0;i<n;i++){
        P[i].pid = i+1;
    }

    cout << "Enter arrival times:\n";
    for (int i=0;i<n;i++) cin >> P[i].arrival;

    cout << "Enter burst times:\n";
    for (int i=0;i<n;i++) cin >> P[i].burst;

    cout << "Enter priorities (lower = higher priority):\n";
    for (int i=0;i<n;i++) cin >> P[i].priority;

    cout << "\nEnter quantum for Round Robin: ";
    int q; cin >> q;

    show_processes(P);

    auto r1 = FCFS(P);
    auto r2 = SJF(P);
    auto r3 = PriorityAlgo(P);
    auto r4 = RoundRobin(P, q);

    show_results("FCFS", P, r1);
    show_results("SJF", P, r2);
    show_results("PRIORITY", P, r3);
    show_results("ROUND ROBIN", P, r4);

    return 0;
}
